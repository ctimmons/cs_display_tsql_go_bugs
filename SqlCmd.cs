/* Unless otherwise noted, this source code is licensed
   under the GNU Public License V3.

   See the LICENSE file in the root folder for details. */

using System;
using System.Diagnostics;
using System.Text;
using System.Text.RegularExpressions;

namespace cs_display_tsql_go_bugs
{
  public class SqlCmd
  {
    public static (Boolean IsInstalled, String Version) GetSqlCmdInfo()
    {
      /* If sqlcmd is installed on a system, running 'sqlcmd -?' outputs header info that looks like this:

           Microsoft (R) SQL Server Command Line Tool
           Version 15.0.1300.359 NT
           Copyright (c) 2015 Microsoft. All rights reserved.
           ...

         Analyze the first two lines to see if it's installed, and - if it is - get the version number. */

      var lines = Regex.Split(RunSqlcmd("-?").Results, @"\r?\n");
      var isInstalled = lines[0].Contains("SQL Server Command Line Tool", StringComparison.CurrentCultureIgnoreCase);
      if (!isInstalled)
        return (false, null!);

      Regex versionNumberRegex = new(@"(?<version_number>\d+\.\d+\.\d+\.\d+)");
      var match = versionNumberRegex.Match(lines[1]);

      return (true, match.Success ? match.Groups["version_number"].Value : null!);
    }

    private static (Boolean HasErrors, String Results) RunSqlcmd(String arguments)
    {
      var hasErrors = false;
      StringBuilder output = new();

      /* Sqlcmd's mode of operation is to split a given T-SQL script on GO statements,
         and then send those statements to an SQL Server instance for execution.
      
         This means sqlcmd produces two kinds of errors: those thrown by sqlcmd itself,
         and errors returned by the SQL Server instance.
      
         This shouldn't make things more complicated, except whoever wrote sqlcmd made it so.
      
         Sqlcmd sends errors thrown by itself to stderr.  However, sqlcmd sends errors
         received from an SQL Server instance to stdout, mixed in with non-error data.

         One might assume that sqlcmd's -m command line switch would be the solution to
         this problem.  The documentation states, in part:

           -m error_level
           Controls which error messages are sent to stdout.
           Messages that have a severity level greater than or equal to this level are sent. 
         
           (source: https://docs.microsoft.com/en-us/sql/tools/sqlcmd-utility?view=sql-server-ver15)

         What's not said is that error messages with a severity level below 'error_level' are completely suppressed.
         As the documentation states, these messages are not sent to stdout.  But the documentation doesn't state
         what, if anything, happens when an error message isn't sent to stdout.  In fact, the error message just disappears.

         Also, the -m setting has no effect on error messages generated by sqlcmd itself.
         For example, "Test Case 03.sql" causes sqlcmd to throw an error which is always sent to stderr. */

      void stderr_DataReceived(Object sender, DataReceivedEventArgs e)
      {
        if (e.Data == null)
          return;

        hasErrors = true;
        output.AppendLine(e.Data);
      }

      /* Errors not created by sqlcmd, but instead received from the SQL Server instance,
         are sent to stdout, according to the 'error_level' value passed via the -m command line option.
         This means those error messages and valid outputs are mixed together in stdout.
      
         To separate the wheat (valid outputs) from the chaff (error messages),
         it's noted that SQL Server-generated errors always seem to start with
         the string "Msg", as in "Msg 113, Level 15, State 1, Server OPUS, Line 5".
         A more robust error detection scheme could be constructed using regular expressions,
         but a simple check for strings starting with "Msg" seems to be good enough for now. */
      void stdout_DataReceived(Object sender, DataReceivedEventArgs e)
      {
        if (e.Data == null)
          return;

        if (e.Data.StartsWith("Msg"))
          hasErrors = true;

        output.AppendLine(e.Data);
      }

      const Int32 oneSecondInMilliseconds = 1000;
      var timeoutInSeconds = 15 * oneSecondInMilliseconds;
      var psi =
        new ProcessStartInfo()
        {
          FileName = "sqlcmd",
          Arguments = arguments,
          RedirectStandardError = true,
          RedirectStandardOutput = true,
          UseShellExecute = false
        };

      using (var process = Process.Start(psi)!)
      {
        process.EnableRaisingEvents = true;
        process.ErrorDataReceived += stderr_DataReceived;
        process.OutputDataReceived += stdout_DataReceived;

        process.BeginErrorReadLine();
        process.BeginOutputReadLine();

        if (process.WaitForExit(timeoutInSeconds))
        {
          /* This code might look a bit weird - why is WaitForExit() being
             called immediately after a successful call to WaitForExit(timeoutInSeconds)?

             It's because the ErrorDataReceived and OutputDataReceived event handlers
             are asynchronous.  They are asychronous because they were redirected
             via the asychronous methods BeginErrorReadLine() and BeginOutputReadLine().

             From the "Remarks" section for WaitForExit():
          
               "This overload ensures that all processing has been completed, including the handling
               of asynchronous events for redirected standard output. You should use this overload
               after a call to the WaitForExit(Int32) overload when standard output has been
               redirected to asynchronous event handlers."

             https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.process.waitforexit?view=net-5.0
          */

          process.WaitForExit();

          return (hasErrors, output.ToString());
        }
        else
        {
          throw new Exception($"The call to 'sqlcmd {arguments}' did not complete within the timeout period of {timeoutInSeconds} seconds.");
        }
      }
    }

    public static String Run(String testCaseFilename)
    {
      var (hasErrors, results) = RunSqlcmd($"-i \"{testCaseFilename}\"");

      return hasErrors ? results : "";
    }
  }
}
